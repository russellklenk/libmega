#include <stdio.h>
#include <stdlib.h>
#include "imutils.hpp"
#include "stb_image.c"

#pragma pack(push, 1)
struct tga_header_t
{
    uint8_t  IDLength;     // 0
    uint8_t  ColorMapType; // 0
    uint8_t  ImageType;    // 2
    uint16_t CMFirst;      // 0
    uint16_t CMCount;      // 0
    uint8_t  CMBits;       // 0
    uint16_t XOrigin;      // 0
    uint16_t YOrigin;      // 0
    uint16_t Width;
    uint16_t Height;
    uint8_t  BitsPerPixel;
    uint8_t  AlphaInfo;
}; // 18 bytes
#pragma pack(pop)

static void print_8x8f(float const *F)
{
    for (size_t row = 0, i = 0; row < 8; ++row, i += 8)
    {
        printf(
            "%4.06f %4.06f %4.06f %4.06f    %4.06f %4.06f %4.06f %4.06f\n", 
            F[i+0], F[i+1], F[i+2], F[i+3], 
            F[i+4], F[i+5], F[i+6], F[i+7]);
    }
    printf("\n");
}

static void print_8x8i(int32_t const *I)
{
    for (size_t row = 0, i = 0; row < 8; ++row, i += 8)
    {
        printf(
            "%08d %08d %08d %08d    %08d %08d %08d %08d\n", 
            I[i+0], I[i+1], I[i+2], I[i+3], 
            I[i+4], I[i+5], I[i+6], I[i+7]);
    }
    printf("\n");
}

static void tile_to_tga(FILE *fp, image_tile_t *tile)
{
    tga_header_t header;

    header.IDLength     = 0;
    header.ColorMapType = 0;
    header.ImageType    = 2;
    header.CMFirst      = 0;
    header.CMCount      = 0;
    header.CMBits       = 0;
    header.XOrigin      = 0;
    header.YOrigin      = 0;
    header.Width        = (uint16_t) tile->TileWidth;
    header.Height       = (uint16_t) tile->TileHeight;
    header.BitsPerPixel = 32;
    header.AlphaInfo    = 0;

    fwrite(&header, 18, 1, fp);
    fwrite(tile->Pixels, tile->BytesPerTile, 1, fp);
}

/// @summary A lookup table of array indices used to access DCT coefficients
/// in zig-zag order, post-FDCT. Accessing the coefficients in zig-zag order
/// increases the length of runs of zeroes.
static const size_t ZigZag[64] =
{
     0,   1,   8,  16,    9,   2,   3,  10,
    17,  24,  32,  25,   18,  11,   4,   5,
    12,  19,  26,  33,   40,  48,  41,  34,
    27,  20,  13,   6,    7,  14,  21,  28,
    35,  42,  49,  56,   57,  50,  43,  36,
    29,  22,  15,  23,   30,  37,  44,  51,
    58,  59,  52,  45,   38,  31,  39,  46,
    53,  60,  61,  54,   47,  55,  62,  63
};

/// @summary Generates a set of Contrast Sensitivity Function coefficients from
/// an existing quantization table, and places the output coefficients into the
/// zig-zag order to increase the length of zero-runs in the quantized DCT 
/// coefficients.
/// @param CSFtable A 64-element array to store the CSF coefficients.
/// @param Qtable A 64-element array of quantization coefficients such as those
/// generated by the quantization_table() function.
static void csf_from_qtable(
    float         * restrict CSFtable, 
    int32_t const * restrict Qtable)
{
    #define DCTSIZE 8U
    for (size_t i = 0; i < DCTSIZE * DCTSIZE; ++i)
    {
        CSFtable[ZigZag[i]] = (float) Qtable[0] / (float) Qtable[i];
    }
}

/// @summary AA&N scale factor values.
static const float AANScaleFactor[8] = 
{
    1.0f, 1.387039845f, 1.306562965f, 1.175875602f, 
    1.0f, 0.785694958f, 0.541196100f, 0.275899379f
};

/// @summary Calculates quantization tables for FDCT and IDCT that account for
/// the scaling introduced by the AA&N methods. The FDCT scales 8-bit input 
/// values by 2^3 (=8); this function includes a baked in de-scale by 8 for use
/// after the FDCT and a re-scale by 8 for use before using a value as input to
/// the IDCT.
/// @param Qidct A 64-element array that will store the scaling and quantization
/// coefficients for use with the IDCT method.
/// @param Qfdct A 64-element array that will store the descale and quantization
/// coefficients for use with the FDCT method.
/// @param CSFTable A 64-element array specifying the Contrast Sensitivity 
/// Function coefficients generated from the quantization table such as those 
/// generated from the csf_from_qtable() function.
static void aan_scaled_qtable(
    float       * restrict Qidct, 
    float       * restrict Qfdct, 
    float const * restrict CSFtable)
{
    #define DCTSIZE 8U
    float const * restrict AAN = AANScaleFactor;
    size_t  i = 0;
    for (size_t r = 0; r < DCTSIZE; ++r)
    {
        for (size_t c = 0; c < DCTSIZE; ++c)
        {
            float  q    = CSFtable ? CSFtable[i] : 1.0f;
            double aans = AAN[r] * AAN[c];
            double qaan = aans   * q;
            Qidct[i]    = (float) (qaan / 8.0);
            Qfdct[i]    = (float) (1.0  / (qaan * 8.0));
            ++i;
        }
    }
}

static void tile_to_page(image_tile_t *tile)
{
    image_tiler_config_t    config;
    image_tile_t            block;

    config.TileWidth     = (size_t) 16;
    config.TileHeight    = (size_t) 16;
    config.ImageWidth    = (size_t) tile->TileWidth;
    config.ImageHeight   = (size_t) tile->TileHeight;
    config.BorderSize    = (size_t) 0;
    config.BorderMode    = BORDER_CLAMP_TO_EDGE;
    config.Pixels        = tile->Pixels;
    tile_alloc(&block, &config);
    size_t nx, ny;
    size_t nt     = tile_count(&nx, &ny, &config);

    int32_t Qbase_y[64];
    int32_t Qbase_c[64]; 
    quantization_table_luma(Qbase_y, 50);
    quantization_table_chroma(Qbase_c, 50);
    printf("Qluma_base:\n");
    print_8x8i(Qbase_y);
    printf("Qchroma_base:\n");
    print_8x8i(Qbase_c);

    float   CSFluma[64];
    float   CSFchroma[64];
    csf_from_qtable(CSFluma, Qbase_y);
    csf_from_qtable(CSFchroma, Qbase_c);
    printf("CSFluma:\n");
    print_8x8f(CSFluma);
    printf("CSFchroma:\n");
    print_8x8f(CSFchroma);

    float   Qidct[64];
    float   Qfdct[64];
    aan_scaled_qtable(Qidct, Qfdct, CSFluma);
    printf("Qidct_base:\n");
    print_8x8f(Qidct);
    printf("Qfdct_base:\n");
    print_8x8f(Qfdct);
    for (size_t i = 0; i < nt; ++i)
    {
        copy_tile(&block, &config, i);
        float Sfdct_Y[256];
        float Sfdct_Co[64];
        float Sfdct_Cg[64];
        float Sfdct_A[256];
        float Qfdct_y[64];
        float Qfdct_c[64];
        // calculate the same tables we did above.
        quantization_tables_encode(Qfdct_y, Qfdct_c, 50);
        // transform and quantize the 16x16 block.
        encode_block_dct(Sfdct_Y, Sfdct_Co, Sfdct_Cg, Sfdct_A, Qfdct_y, Qfdct_c, (uint8_t const*) block.Pixels);
        // dump the FDCT'd and quantized coefficients.
        printf("Sub-block 0 for block %u.\n", (unsigned) i);
        print_8x8f(&Sfdct_Y[0]);
        // now reverse the transform for one block.
        float Qidct_y[64];
        float Qidct_c[64];
        float Sidct_Y[64];
        quantization_tables_decode(Qidct_y, Qidct_c, 50);
        idct8x8(Sidct_Y, &Sfdct_Y[0], Qidct_y);
        print_8x8f(&Sidct_Y[0]);
    }
    tile_free (&block);
}

static void test_reversability(void)
{
    float base_vals[64];
    float start_val = -32.0f;

    // the transform expects values in the range [-128, 127], 
    // so generate some initial values that are valid.
    for (size_t i = 0; i < 64; ++i)
        base_vals[i] = start_val + (i*2)-1;
    printf("base_vals:\n");
    print_8x8f(base_vals);

    float Qidct_y[64];
    float Qfdct_y[64];
    aan_scaled_qtable(Qidct_y, Qfdct_y, NULL);

    //float Qfdct_y[64];
    //float Qfdct_c[64];
    //quantization_tables_encode(Qfdct_y, Qfdct_c, 100);

    float fdct_vals[64];
    fdct8x8(fdct_vals, base_vals, Qfdct_y);
    printf("fdct_vals:\n");
    print_8x8f(fdct_vals);

    //float Qidct_y[64];
    //float Qidct_c[64];
    //quantization_tables_decode(Qidct_y, Qidct_c, 100);

    float idct_vals[64];
    idct8x8(idct_vals, fdct_vals, Qidct_y);
    printf("idct_vals:\n");
    print_8x8f(idct_vals);
}

int main(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("USAGE: chunker file block_size\n");
        return 1;
    }

    int x, y, n;
    uint8_t *image_data = stbi_load(argv[1], &x, &y, &n, 4);
    int s = atoi(argv[2]);

    image_tiler_config_t  config;
    image_tile_t          tile;

    config.TileWidth   = (size_t) s;
    config.TileHeight  = (size_t) s;
    config.ImageWidth  = (size_t) x;
    config.ImageHeight = (size_t) y;
    config.BorderSize  = (size_t) 0;
    config.BorderMode  = BORDER_CLAMP_TO_EDGE;
    config.Pixels      = image_data;
    tile_alloc(&tile, &config);

    size_t nx, ny;
    size_t nt     = tile_count(&nx, &ny, &config);
    for (size_t i = 0; i < nt; ++i)
    {
        copy_tile(&tile, &config, i);

        char filename[128];
        memset (filename, 0, sizeof(filename));
        sprintf(filename, "%d_%d.tga", (int) tile.TileX, (int) tile.TileY);
        FILE *fp = fopen(filename, "wb");
        tile_to_tga(fp, &tile);
        fclose(fp);
        if (i == 0) tile_to_page(&tile);
    }
    tile_free(&tile);
    stbi_image_free(image_data);
    printf("\n\n\n\n");
    test_reversability();
    return 0;
}

